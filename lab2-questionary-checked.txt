=== This template file contains questions you need to answer.
=== Fill your answers on appropriate blank lines only.
=== Don't start any line with three equal signs "===".
=== Don't edit any lines starting from three equal signs.
=== Use C notation to write numbers: 42 for decimal, 0x2a for hexadecimal.
=== We may check most of the answers automatically, so "forty two" or
=== "26+16" won't work for this example. Spaces are mostly ignored, so
=== "  42  " is OK (without quotes of course). 
=== When asked to specify address & instruction, do it in the form of
=== gdb output "ADDRESS: INSTRUCTION", for example "0x7c26:  or  $0x1,%eax"
=== Don't make lines longer than 80 characters. You don't need to fit your
=== answer in a single line, you can start a new line at will.
=== However, when asked to fill "a table" make each table raw a single line.


=== Q What's the purpose of leaving virtual memory region
===   0xeebfe000-0xeebff000 inaccessible?
===   (free form, up to 10 words)
	This is protection page between Exception and Normal user stacks
	to detect exception stack overflow.[-1 too long]

=== Q Define a page table entry with the following properties:
===   frame starts at 0x1234000. It can be written by the kernel
===   without causing any errors, but has never been written yet. On
===   the other hand, application cannot write to the page, but has
===   recently successfully read from it. All bits which are not
===   responsible for above properties are set to zero.  
===   (a single memory WORD as would be output by gdb's x/1x)
	0x1234023 [-1 0x01234025]

=== Q Consider JOS kernel code:
===     mystery_t x;
===   	char* value = return_a_pointer();
===   	*value = 10;
===   	x = (mystery_t) value;
===   What type mystery_t should refer to?
===   (remove leading "====" from the correct answer line)
     uintptr_t
==== physaddr_t


=== Q What information is stored in page directory when mem_init()
===   finishes? For each non-empty PD entry specify:
===    - decimal index (0-1023)
===    - hexadecimal address of virtual memory mapped by this entry
===    - name of kernel data structure which is intended to be
===      accessible through this PDE (when appropriate, in quotes)
===    - general name (free form, up to 10 words in quotes)
===    Sort the table by the index in ascending order. If several
===    consequent entries are only differ in address field, you can
===    specify ellipses ("...") instead of an "inner" entries. Please
===    align columns into readable table using spaces.
===    Format example (all the values are made up; omit the header):
===    INDEX ADDRESS DATA-STRUCTURE         NAME/DESCRIPTION
===    24    0x12345 "struct Segdesc gdt[]" "Global descriptor table"
===    ...
===    42    0x98765 "struct Segdesc gdt[]" "Global descriptor table"
===    50    0x00011 ""                     "boot loader code"
	956:	0xef000000	"struct PageInfo *pages"	"Phys. pages registry"
	957:	0xf011a000	"pde_t *kern_pgdir"			"Page directory itself" [-1 page tables, wrong address]
	958:	UNMAPPED
	959:	0xefff8000	"char bootstack[]"			"Kernel stack"
	960:	0xf0000000								"Kernel accessible memory - 256MB"
	...
	1023:	0xfffff000

=== Q We have placed the kernel and user environment in the same
===   address space. Why will user programs not be able to read or
===   write the kernel's memory? What specific mechanisms protect the
===   kernel memory?
===   (free form, up to 15 words)
	Permission bits in page directory / page table entries - U, R and CR0 register
	that allows to apply write protection to userland only or both user and kernel. (Again, too long)

=== Q Which virtual addresses are readable by the user?
===   (in the form ADDR1-ADDR2, if none, specify NONE)
	0xef000000
	0xf011a000 [-1 wrong format, also wrong addresses 0xf0000000-... is inaccesible]

=== Q Which virtual addresses are writable by the user?
===   (in the form ADDR1-ADDR2, if none, specify NONE)
	NONE

=== Q Assume a hacker can change N bits inside page table (on any
===   level, PD or PT) after it has been set up by the kernel (and
===   before full TLB flush). What is the minimal N to gain full
===   control of the system from hacker's user space process?
	1 - R-bit in kern_pgdir[957], that maps itself - it would allow
		the hacker to overwrite freely the whole kern_pgdir gaining
		full access to all the memory.

=== Q What's the maximum amount of physical memory this kernel can
===   support? (number of megabytes, without MB suffix)
	256

=== Q What single constant can be changed in kernel source to make
===   this limit 2 times lower (if kernel normally supports 10MB,
===   we want to make it support only 5MB?
	KERNBASE

=== Q What value should this constant be changed to?
	0xf8000000

=== Q Assume the computer has the maximum amount of memory supported
===   by the (unmodified) kernel. What's the overhead of managing this
===   memory in terms of (physical) memory spent?
===   Specify only data structures which size depends on the amount of
===   physical memory and exclude the "fixed" overhead. For example,
===   if data structure size is 123K+0.01*(memory size) and maximum 
===   amount of memory is 100MB, specify 0.01*100MB = 1024KB.
===   For each such data structure specify:
===    - size in KB (without "KB suffix")
===    - name of kernel data structure (when appropriate, in quotes)
===    - general name (free form, up to 10 words in quotes)
===    Sort the table by the size in ascending order. Please
===    align columns into readable table using spaces.
===    Format example (all the values are made up; omit the header):
===    SIZE  DATA-STRUCTURE         NAME/DESCRIPTION
===    42    "struct Segdesc gdt[]" "Global descriptor table"
	256		"64 memory page tables" [-2 page allocation structures]

====================================================================
=== Q What challenge(s) have you chosen to implement? (specify
===   challenge numbers separated by spaces, if more than one)
	2 - extending JOS kernel monitor with memory mapping commands

=== Q If the challenge requires changing the kernel source, list the
===   files which you have changed/added during implementation.
===   (one file per line, relative to lab directory containing .git/)
	monitor.h
	monitor.c

=== Q Describe you solution.
===   (free form, up to 500 words, don't need to use all 500!)
	3 new monitor commands were added:
	- showmappings
	- mapping_perms
	- memdump
	1) showmappings start-addr [stop-addr]
		This command shows memory mapping information in the following format:
		<pagedir index>:<pagetab index>
		<virt. addr. rounded down to page start>
		<pagedir entry>
		<pagetab entry>
	
	2) mapping_perms pagedir-index[:pagetab-index] [new-perms]
		This command displays and changes page directory / table permissions.
		Pagedir and pagetab indeces are as displayed in 'showmappings'.
		new-perms is the permissions word to be applied to memory mapping flags - in case
			it is omitted, currently set permissions will be displayed.

	3) memdump /v start-addr [stop-addr]
		This command displays the contents of virtual memory range.

	   memdump /p start-addr [stop-addr]
		This command displays the contents of physical memory range.
		
	   The memory locations may belong to either virtual or physical memory -
	   as required by '/v' / '/p' switch. In case a particular page is not
	   mapped 'UNMAPPED' will be displayed instead of memory cell contents.
	   The memory contents will be displayed byte by byte.


---------------------
DryScore: 14/20
WetScore: 80/80
LatePenalty:  -15
Total:    79/100

